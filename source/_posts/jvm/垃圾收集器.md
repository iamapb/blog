---
title: 垃圾收集器
date: 2022-04-23 23:13:57
tags: jvm
---

### jvm垃圾收集总结
#### 1 jvm对象判断，以及垃圾收集算法总结

```xml

判断堆中的对象是否为垃圾有两种形式:
1 引用计数法: 对象中添加一个引用计数器，引用了就加一，引用失效就减一，不足: 对象之间循环引用无法解决
2 可达性分析算法: GCRoot根对象的这个节点到某个对象的之间的引用链是否相连问题

由于用的都是可达性分析算法，大部分的对象都是朝生夕灭的，少部分是熬过很多次垃圾收集，难以消亡。
所以，收集器应该将java堆划分出不同的区域，将回收对象依据年龄分配到不同的区域存储，用于后期回收。因而就有了

MinorGC: 新生代回收
MajorGC: 老年代回收
FullGC: 整堆回收

针对不同的区域安排和里面的存储对象的特征，就有了三种不同的垃圾回收算法:
1 标记-清除算法(Mark-Sweep)-基础: 首先标记所有需要清楚的对象，再统一回收掉
缺点: 1 执行效率不稳定 2 会产生很多的琐碎的内存空间

2 标记-复制(用于新生到): 将使用的堆内存一分为二，使用其中的一半。使用玩了后，
就把上面还存活的对象复制到另外一半上，然后整体q清除这一半的对象。
缺点: 空间浪费比较严重
用途: 使用这种算法去回收新生代，新生代的对象大部分的都是可以被回收的，所以比较浪费。
因此，新生代的区域被分为 Eden和Survivor1，Survivor2 区域，只使用Eden和Survivor1，Survivor2 只是预留的空间，
用于存放垃圾处理之后的存活的对象。如果空间不足，就需要老年代提供内存空间支持。(这就是新生代为什么这么分配的原因)
3 标记-整理(用于老年代): 先标记，后将存活的对象向内存空间的一端移动。

对比:
        M-S 标记-清除     M-C 标记整理       COPY 标记-复制
速度          中等           最慢             最快
空间开销       少            少                多
移动对象       否            是                是

```
### 2 垃圾收集器总结
#### 2.1 Serial收集器
>一个单线程的工作收集器.在进行垃圾收集的时候，必须暂停其他所有工作线程，直到它收集结束.

```xml
优点: 简单和高效,内存消耗小，专心做垃圾的收集
```

#### 这里需要说明一个词: Stop The World
>这项工作是由虚拟机在后台自动发起和自动完成的，在用户不知情的情况下，把用户的正常工作的线程全部停掉. 
>(这种情况是无法消除的，只能尽量减少停顿时间)

#### 2.2 Serial Old 收集器 老年代收集器

#### 2.3 ParNew
```xml
是Serial收集器的多线程并行版本,除了同时使用多线程进行垃圾收集之外，其余的功与Serial的收集器的一摸一样.
运行在服务端模式下的HotSpot虚拟机，除了Serial收集器外，只有它能与CMS收集器配合工作.

```

#### 2.4 Parallel Scavenge
```xml
新生代收集器，基于标记-复制算法实现，并行收集的多线程收集器
特点: 尽可能达到一个可控制的吞吐量
```

#### 2.5 Parallel Old (1.6)
```xml
> STop The World：是虚拟机在后台自动发起和自动完成的，在用户不可知，不可控的情况下，把用户的正常工作的线程全部停掉。
#### 2.6 CMS(Concurrent Mark Sweep) 
>基于标记-清除算法实现，以获取最短回收停顿时间为目标。

整个过程分为四个步骤
```xml
1 初始标记) 关联一下GC Roots能直接关联到对象，速度很快。
2 并发标记) 从GCRoots 的直接直接关联对象开始遍历整个对象图的过程，过程很漫长，但是不需要停顿用户线程
3 重新标记) 因为在2阶段用户可能产生新的标记，所以为了修正这些标记记录
4 并发清除) 清除删除掉标记阶段判断的已经死亡的对象,可以与用户并发执行，因为不需要移动存活对象

缺点:
  1 CMS对处理器资源非常敏感,
  2 CMS收集器无法处理"浮动垃圾". 浮动垃圾就是在 2，4 阶段的时候，用户线程还在继续运行，
就会产生对应的垃圾对象，这部分是不会处理的，只能在下次再清理掉。
  3 CMS是基于 标记-清除算法实现的，会产生大量的空间碎片.
```

#### 2.7 Garbage First jdk 9

>面向服务端应用的垃圾收集器,开创了收集器面向局部收集的思路和基于Region的内存布局形式.
```xml
收集器的四个步骤:
  1 初始标记)  标记一下GC Roots能够直接关联到的对象,并且修改TAMS指针的值。
   需要停顿用户线程，耗时很短，在MinorGC的时候就可以同步完成
  2 并发标记) 从GC Roots 开始对堆中的对象进行可达性分析，递归扫描整个堆里面的对象图
   找到要回收的对象。耗时很长，可以与用户线程并发执行
  3 最终标记) 对用户线程做另一个短暂的暂停。用于处理并发阶段结束后遗留下来的最后那少量的SATB记录
  4 筛选回收) 对Region进行统计和回收
```

#### 2.8 ZGC 收集器 jdk 11
> 具有实验性质的低延迟垃圾收集器，在对吞吐量影响不大的情况下，在任意推内存大小下都可以把垃圾手机的停顿时间在10毫秒之内的低延迟。

```xml

采用基于Region的堆内存布局，Region 具有动态性---动态创建和销毁，以及动态的区域容量大小。
采用并发整理算法去实现，
```

各种垃圾收集器在虚拟机上的分布
![](/../../static/jvm/收集器分布.jpg)


 





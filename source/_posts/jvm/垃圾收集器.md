---
title: 垃圾收集器
date: 2022-04-23 23:13:57
tags: jvm
---

### jvm垃圾收集总结
#### 1 jvm对象判断，以及垃圾收集算法总结

```xml

判断堆中的对象是否为垃圾有两种形式:
1 引用计数法: 对象中添加一个引用计数器，引用了就加一，引用失效就减一，不足: 对象之间循环引用无法解决
2 可达性分析算法: GCRoot根对象的这个节点到某个对象的之间的引用链是否相连问题

由于用的都是可达性分析算法，大部分的对象都是朝生夕灭的，少部分是熬过很多次垃圾收集，难以消亡。
所以，收集器应该将java堆划分出不同的区域，将回收对象依据年龄分配到不同的区域存储，用于后期回收。因而就有了

MinorGC: 新生代回收
MajorGC: 老年代回收
FullGC: 整堆回收

针对不同的区域安排和里面的存储对象的特征，就有了三种不同的垃圾回收算法:
1 标记-清除算法(Mark-Sweep)-基础: 首先标记所有需要清楚的对象，再统一回收掉
缺点: 1 执行效率不稳定 2 会产生很多的琐碎的内存空间

2 标记-复制(用于新生到): 将使用的堆内存一分为二，使用其中的一半。使用玩了后，
就把上面还存活的对象复制到另外一半上，然后整体q清除这一半的对象。
缺点: 空间浪费比较严重
用途: 使用这种算法去回收新生代，新生代的对象大部分的都是可以被回收的，所以比较浪费。
因此，新生代的区域被分为 Eden和Survivor1，Survivor2 区域，只使用Eden和Survivor1，Survivor2 只是预留的空间，
用于存放垃圾处理之后的存活的对象。如果空间不足，就需要老年代提供内存空间支持。(这就是新生代为什么这么分配的原因)
3 标记-整理(用于老年代): 先标记，后将存活的对象向内存空间的一端移动。

对比:
        M-S 标记-清除     M-C 标记整理       COPY 标记-复制
速度          中等           最慢             最快
空间开销       少            少                多
移动对象       否            是                是

```

#### 2 垃圾收集器总结
##### 2.1 Serial收集器(最早的)
> 单线程工作的垃圾收集器,在垃圾收集的时候,是单线程去完成垃圾收集工作，收集垃圾时，必须暂停其他所有的工作线程。

> STop The World：是虚拟机在后台自动发起和自动完成的，在用户不可知，不可控的情况下，把用户的正常工作的线程全部停掉。

 ##### 2.2 ParNew收集器 
 > 是Serial 收集器的对线程的并行版本,其余的功能和Serial收集器大致差不多.可以搭配CMS使用(JDK 5环境下).
 ParNew收集器是激活CMS后（使用-XX：+UseConcMarkSweepGC选项）的默 认新生代收集器，也可以使用-XX：+/-UseParNewGC选项来强制指定或者禁用它





---
title: redis线程模型
date: 2021-02-22 14:27:50
tags: redis
---
### 1 什么是redis的线程模型

![模型图片](/../../static/redis/redis线程模型.png)

```xml

    redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。
```
为啥 redis 单线程模型也能效率这么高？
+ 纯内存操作, 数据是存在内存中
+ 核心是基于非阻塞的 IO 多路复用机制
+ 单线程反而避免了多线程的频繁上下文切换问题

过期数据的删除对redis的性能影响 --- 三种删除策略
+ 1.定时删除 在设置键的过期时间的同时，创建一个定时器Timer，让定时器在键过期时间来临时立即执行对过期键的删除 (对CPU不友好 影响性能)
+ 2.惰性删除 键过期不管，每次读取该键的时候，判断该键是否过期，如果过期删除该键返回空  (内存不友好 占内存空间)
+ 3.定期删除 每隔一段时间对内存中的过期键进行一次检查 (折中方案)

具体操作
 采用 定时删除和惰性删除进行key的删除

### 2、Redis的内存淘汰机制

Redis内存淘汰策略是指当缓存内存不足时，通过淘汰旧数据处理新加入数据选择的策略。
如何配置最大内存？
（1）通过配置文件配置
修改redis.conf配置文件
> maxmemory 1024mb //设置Redis最大占用内存大小为1024M

注意：maxmemory默认配置为0，在64位操作系统下redis最大内存为操作系统剩余内存，在32位操作系统下redis最大内存为3GB。（2）通过动态命令配置
Redis支持运行时通过命令动态修改内存大小：
```xml
    127.0.0.1:6379> config set maxmemory 200mb //设置Redis最大占用内存大小为200M
    127.0.0.1:6379> config get maxmemory //获取设置的Redis能使用的最大内存大小
    1) "maxmemory"
    2) "209715200"

```

淘汰策略的分类
Redis最大占用内存用完之后，如果继续添加数据，如何处理这种情况呢？实际上Redis官方已经定义了八种策略来处理这种情况：
noeviction
默认策略，对于写请求直接返回错误，不进行淘汰。
allkeys-lru
lru(less recently used), 最近最少使用。从所有的key中使用近似LRU算法进行淘汰。
volatile-lru
lru(less recently used), 最近最少使用。从设置了过期时间的key中使用近似LRU算法进行淘汰。
allkeys-random
从所有的key中随机淘汰。
volatile-random
从设置了过期时间的key中随机淘汰。
volatile-ttl
ttl(time to live)，在设置了过期时间的key中根据key的过期时间进行淘汰，越早过期的越优先被淘汰。
allkeys-lfu
lfu(Least Frequently Used)，最少使用频率。从所有的key中使用近似LFU算法进行淘汰。从Redis4.0开始支持。
volatile-lfu
lfu(Least Frequently Used)，最少使用频率。从设置了过期时间的key中使用近似LFU算法进行淘汰。从Redis4.0开始支持。
注意：当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有设置过期的key可以被淘汰，则和noeviction一样返回错误。
LRU算法
LRU(Least Recently Used)，即最近最少使用，是一种缓存置换算法。在使用内存作为缓存的时候，缓存的大小一般是固定的。当缓存被占满，这个时候继续往缓存里面添加数据，就需要淘汰一部分老的数据，释放内存空间用来存储新的数据。这个时候就可以使用LRU算法了。其核心思想是：如果一个数据在最近一段时间没有被用到，那么将来被使用到的可能性也很小，所以就可以被淘汰掉。
LRU在Redis中的实现
Redis使用的是近似LRU算法，它跟常规的LRU算法还不太一样。近似LRU算法通过随机采样法淘汰数据，每次随机出5个（默认）key，从里面淘汰掉最近最少使用的key。
可以通过maxmemory-samples参数修改采样数量， 如：maxmemory-samples 10
maxmenory-samples配置的越大，淘汰的结果越接近于严格的LRU算法，但因此耗费的CPU也很高。
Redis为了实现近似LRU算法，给每个key增加了一个额外增加了一个24bit的字段，用来存储该key最后一次被访问的时间。
Redis3.0对近似LRU的优化
Redis3.0对近似LRU算法进行了一些优化。新算法会维护一个候选池（大小为16），池中的数据根据访问时间进行排序，第一次随机选取的key都会放入池中，随后每次随机选取的key只有在访问时间小于池中最小的时间才会放入池中，直到候选池被放满。当放满后，如果有新的key需要放入，则将池中最后访问时间最大（最近被访问）的移除。
当需要淘汰的时候，则直接从池中选取最近访问时间最小（最久没被访问）的key淘汰掉就行。
LFU算法
LFU(Least Frequently Used)，是Redis4.0新加的一种淘汰策略，它的核心思想是根据key的最近被访问的频率进行淘汰，很少被访问的优先被淘汰，被访问的多的则被留下来。
LFU算法能更好的表示一个key被访问的热度。假如你使用的是LRU算法，一个key很久没有被访问到，只刚刚是偶尔被访问了一次，那么它就被认为是热点数据，不会被淘汰，而有些key将来是很有可能被访问到的则被淘汰了。如果使用LFU算法则不会出现这种情况，因为使用一次并不会使一个key成为热点数据。

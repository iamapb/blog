---
title: REDIS缓存穿透，缓存击穿，缓存雪崩原因+解决方案
date: 2021-02-21 17:32:30
tags: redis
---
### 1 定义
  + 缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。
  + 缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
  + 缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。
  
### 2、缓存穿透解决方案

>   一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。   
   有很多种方法可以有效地解决缓存穿透问题
   
  + 1 最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
  + 2 另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
      粗暴方式伪代码：
```xml
   //伪代码
   public object GetProductListNew() {
       int cacheTime = 30;
       String cacheKey = "product_list";
   
       String cacheValue = CacheHelper.Get(cacheKey);
       if (cacheValue != null) {
           return cacheValue;
       }
   
       cacheValue = CacheHelper.Get(cacheKey);
       if (cacheValue != null) {
           return cacheValue;
       } else {
           //数据库查询不到，为空
           cacheValue = GetProductListFromDB();
           if (cacheValue == null) {
               //如果发现为空，设置个默认值，也缓存起来
               cacheValue = string.Empty;
           }
           CacheHelper.Add(cacheKey, cacheValue, cacheTime);
           return cacheValue;
       }
   }

```

### 3 缓存击穿方案
1 使用互斥所
就是让一个线程回写缓存， 其他的线程等待回写缓存线程执行完，重新读缓存即可。
![](/../../static/redis/redis-缓存击穿.png)

同一时间只有一个线程读数据库然后回写缓存，其他线程都处于阻塞状态。如果是高并发场景，大量线程阻塞势必会降低吞吐量。这种情况如何解决？大家可以在留言区讨论。
如果是分布式应用就需要使用分布式锁。

2 方案二：热点数据永不过期
 永不过期实际包含两层意思：
 物理不过期，针对热点key不设置过期时间
 逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建
 ![](/../../static/redis/redis-缓存击穿-2.png)
 
 从实战看这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，对于不追求严格强一致性的系统是可以接受的。




### 3 redis雪崩的预防
  + 1 永不过期 跟缓存击穿解决思路一致，缓存在物理上永远不过期，用一个异步的线程更新缓存。
  + 2 过期时间错开 设置不同的过期时间，让缓存失效的时间点尽量均匀。通常可以为有效期增加随机值或者统一规划有效期。
  + 3 多缓存结合
 使用主备两层缓存：
 主缓存：有效期按照经验值设置，设置为主读取的缓存，主缓存失效后从数据库加载最新值。
 备份缓存：有效期长，获取锁失败时读取的缓存，主缓存更新时需要同步更新备份缓存。
 
